<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FIFA PREDICT PRO - Prédictions de Match</title>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script src="https://unpkg.com/framer-motion@4.1.17/dist/framer-motion.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }
        .pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        .score-list {
            background-color: #f3f4f6;
            border-radius: 0.5rem;
            padding: 1rem;
            max-height: 200px;
            overflow-y: auto;
        }
        .score-item {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid #e5e7eb;
        }
        .score-item:last-child {
            border-bottom: none;
        }
        .score-label {
            flex: 0 0 auto;
            width: 4rem;
            font-size: 0.875rem;
            font-weight: 600;
            color: #4b5563;
        }
        .score-inputs {
            display: flex;
            flex: 1;
            gap: 0.5rem;
        }
        .score-input {
            flex: 1;
            max-width: 3rem;
            font-size: 0.875rem;
        }
        @media (max-width: 640px) {
            .sm\:max-w-xl {
                max-width: 100%;
                width: 100%;
            }
            .sm\:p-12 {
                padding: 1rem;
            }
            .relative.py-3 {
                padding: 0;
            }
            .relative.px-4.py-6 {
                padding: 1rem;
            }
            .probability-container {
                grid-template-columns: 1fr;
            }
        }
        html, body, #root {
            height: 100%;
            overflow: hidden;
        }
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            background-image: url('https://websim.creation.engine/fifa-predict-pro/soccer-field-bg.jpg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
        }
        .content-wrapper {
            flex: 1;
            overflow-y: auto;
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 1.5rem;
            width: 100%;
            max-width: 800px;
        }
        @media (min-width: 640px) {
            .content-wrapper {
                max-width: 600px;
            }
        }
        @media (min-width: 768px) {
            .content-wrapper {
                max-width: 720px;
            }
        }
        @media (min-width: 1024px) {
            .content-wrapper {
                max-width: 800px;
            }
        }
        .prediction-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
        }
        .prediction-item {
            background-color: rgba(45, 55, 72, 0.9);
            border-radius: 0.5rem;
            padding: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .prediction-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        .prediction-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #e2e8f0;
            margin-bottom: 0.5rem;
        }
        .prediction-score {
            font-size: 1.25rem;
            font-weight: 700;
            color: #fff;
        }
        .welcome-message {
            background-color: rgba(240, 244, 255, 0.9);
            border-left: 4px solid #4f46e5;
            padding: 1rem;
            margin-bottom: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .welcome-message p {
            font-size: 0.875rem;
            line-height: 1.5;
            color: #4b5563;
        }
        .probability-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            background-color: rgba(45, 55, 72, 0.9);
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        @media (max-width: 640px) {
            .probability-container {
                grid-template-columns: 1fr;
            }
        }
        .probability-item {
            background-color: rgba(74, 85, 104, 0.9);
            padding: 0.75rem;
            border-radius: 0.5rem;
            text-align: center;
            transition: transform 0.3s ease;
        }
        @media (max-width: 640px) {
            .probability-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
        }
        .probability-item h3 {
            color: #e2e8f0;
        }
        .probability-item p {
            color: #fff;
        }
        footer {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .social-links {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }
        .social-link {
            color: #4b5563;
            text-decoration: none;
            transition: color 0.3s ease;
        }
        .social-link:hover {
            color: #1d4ed8;
        }
        footer {
            background-color: rgba(255, 255, 255, 0.9);
            padding: 0.5rem;
            text-align: center;
            font-size: 0.75rem;
            color: #4b5563;
            box-shadow: 0 -1px 3px rgba(0, 0, 0, 0.1);
        }
        .custom-input {
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #d1d5db;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .custom-input:focus {
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
        }
        .custom-button {
            transition: background-color 0.3s ease, transform 0.3s ease;
        }
        .custom-button:hover {
            transform: translateY(-2px);
        }
        .loading-overlay {
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
        }
        .loading-spinner {
            border-top-color: #4f46e5;
        }
    </style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState } = React;
const { motion, AnimatePresence } = window.Motion;

const FifaPredictPro = () => {
  const [currentSection, setCurrentSection] = useState('home');

  const renderSection = () => {
    switch (currentSection) {
      case 'home':
        return <HomePage setCurrentSection={setCurrentSection} />;
      case 'fifa-classique':
        return <FifaClassique setCurrentSection={setCurrentSection} />;
      case 'sega-football':
        return <SegaFootball setCurrentSection={setCurrentSection} />;
      case 'fifa-hot':
        return <FifaHot setCurrentSection={setCurrentSection} />;
      default:
        return <HomePage setCurrentSection={setCurrentSection} />;
    }
  };

  return (
    <div className="app-container">
      <div className="content-wrapper">
        {renderSection()}
      </div>
      <footer>
        <p className="font-bold">AL VE CAPITAL</p>
        <p>© 2024 Tous droits réservés</p>
      </footer>
    </div>
  );
};

const HomePage = ({ setCurrentSection }) => {
  return (
    <div className="space-y-6">
      <h1 className="text-3xl font-extrabold text-indigo-600 text-center mb-6">FIFA PREDICT PRO</h1>
      <div className="welcome-message mt-4 mb-8">
        <p className="text-center text-gray-600">
          Bienvenue sur FIFA PREDICT PRO, votre outil ultime pour des prédictions de football précises et fiables. Notre application utilise des modèles de calcul avancés pour fournir des prédictions de haute qualité pour FIFA Classique, SEGA FOOTBALL et FIFA HOT.
        </p>
      </div>
      <div className="social-links flex justify-center space-x-4 mb-8">
        <a href="https://youtube.com/@alvecapital?si=4Z6KpE28K1PUycqK" target="_blank" rel="noopener noreferrer" className="text-indigo-600 hover:text-indigo-800 transition-colors">
          YouTube
        </a>
        <a href="https://t.me/alvecapital1" target="_blank" rel="noopener noreferrer" className="text-indigo-600 hover:text-indigo-800 transition-colors">
          Telegram
        </a>
      </div>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        <div className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition-shadow">
          <h2 className="text-xl font-bold text-indigo-600 mb-4">FIFA Classique</h2>
          <button
            onClick={() => setCurrentSection('fifa-classique')}
            className="custom-button w-full p-4 bg-indigo-600 text-white rounded-lg shadow-md hover:bg-indigo-700 transition-colors"
          >
            Commencer
          </button>
        </div>
        <div className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition-shadow">
          <h2 className="text-xl font-bold text-green-600 mb-4">SEGA FOOTBALL</h2>
          <button
            onClick={() => setCurrentSection('sega-football')}
            className="custom-button w-full p-4 bg-green-600 text-white rounded-lg shadow-md hover:bg-green-700 transition-colors"
          >
            Explorer
          </button>
        </div>
        <div className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition-shadow">
          <h2 className="text-xl font-bold text-red-600 mb-4">FIFA HOT</h2>
          <button
            onClick={() => setCurrentSection('fifa-hot')}
            className="custom-button w-full p-4 bg-red-600 text-white rounded-lg shadow-md hover:bg-red-700 transition-colors"
          >
            Découvrir
          </button>
        </div>
      </div>
    </div>
  );
};

const FifaClassique = ({ setCurrentSection }) => {
  const [step, setStep] = useState(1);
  const [odds, setOdds] = useState({ home: '', draw: '', away: '' });
  const [previousScores, setPreviousScores] = useState(Array(5).fill({ home: '', away: '' }));
  const [predictions, setPredictions] = useState(null);
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleOddsChange = (e) => {
    setOdds({ ...odds, [e.target.name]: e.target.value });
  };

  const handlePreviousScoresChange = (index, team, value) => {
    const newScores = [...previousScores];
    newScores[index] = { ...newScores[index], [team]: value };
    setPreviousScores(newScores);
  };

  const calculatePredictions = () => {
    setError('');
    setLoading(true);

    if (!odds.home || !odds.draw || !odds.away) {
      setError('Veuillez entrer toutes les cotes.');
      setLoading(false);
      return;
    }

    const homeOdds = parseFloat(odds.home);
    const drawOdds = parseFloat(odds.draw);
    const awayOdds = parseFloat(odds.away);

    if (homeOdds <= 1 || drawOdds <= 1 || awayOdds <= 1) {
      setError('Les cotes doivent être supérieures à 1.');
      setLoading(false);
      return;
    }

    const validScores = previousScores.filter(score => score.home !== '' && score.away !== '');
    if (validScores.length === 0) {
      setError('Veuillez entrer au moins un score valide.');
      setLoading(false);
      return;
    }

    setTimeout(() => {
      const totalProb = (1 / homeOdds) + (1 / drawOdds) + (1 / awayOdds);
      const homeProb = (1 / homeOdds) / totalProb * 100;
      const drawProb = (1 / drawOdds) / totalProb * 100;
      const awayProb = (1 / awayOdds) / totalProb * 100;

      const avgHomeScore = validScores.reduce((sum, score) => sum + parseInt(score.home), 0) / validScores.length;
      const avgAwayScore = validScores.reduce((sum, score) => sum + parseInt(score.away), 0) / validScores.length;

      const predictScore = (avgScore, prob, factor = 1) => {
        const baseScore = avgScore * (prob / 50) + Math.random() * 0.5;
        return Math.max(0, Math.round(baseScore * factor * (1 + (Math.random() - 0.5) * 0.2)));
      };

      let homeScore1, awayScore1, homeScore2, awayScore2;
      do {
        homeScore1 = predictScore(avgHomeScore, homeProb, 1.3);
        awayScore1 = predictScore(avgAwayScore, awayProb, 1.3);
        homeScore2 = predictScore(avgHomeScore, homeProb, 1.4);
        awayScore2 = predictScore(avgAwayScore, awayProb, 1.4);
      } while (homeScore1 === homeScore2 && awayScore1 === awayScore2);

      const totalGoals1 = homeScore1 + awayScore1;
      const totalGoals2 = homeScore2 + awayScore2;
      const avgTotalGoals = (totalGoals1 + totalGoals2) / 2;

      let mostLikelyGoals;
      let reliability;

      if (avgTotalGoals <= 2.5) {
        mostLikelyGoals = "2.5";
        reliability = Math.floor(85 + (avgTotalGoals / 2.5) * 10);
      } else if (avgTotalGoals <= 3.5) {
        mostLikelyGoals = "3.5";
        reliability = Math.floor(80 + ((avgTotalGoals - 2.5) / 1) * 15);
      } else {
        mostLikelyGoals = "4.5";
        reliability = Math.floor(75 + ((avgTotalGoals - 3.5) / 1.5) * 20);
      }

      reliability = Math.min(95, Math.max(70, reliability));

      let mostLikelyOutcome;
      if (homeProb > awayProb && homeProb > drawProb) {
        mostLikelyOutcome = homeProb - drawProb > 20 ? "1" : "1X";
      } else if (awayProb > homeProb && awayProb > drawProb) {
        mostLikelyOutcome = awayProb - drawProb > 20 ? "2" : "2X";
      } else {
        mostLikelyOutcome = "12";
      }

      setPredictions({
        probabilities: {
          home: homeProb.toFixed(2),
          draw: drawProb.toFixed(2),
          away: awayProb.toFixed(2)
        },
        scores: {
          fullTime: [`${homeScore1} - ${awayScore1}`, `${homeScore2} - ${awayScore2}`],
          halfTime: [
            `${Math.max(0, Math.floor(homeScore1 / 2))} - ${Math.max(0, Math.floor(awayScore1 / 2))}`,
            `${Math.max(0, Math.floor(homeScore2 / 2))} - ${Math.max(0, Math.floor(awayScore2 / 2))}`
          ]
        },
        goalsPrediction: {
          value: mostLikelyGoals,
          reliability: reliability
        },
        mostLikelyOutcome: mostLikelyOutcome
      });

      setLoading(false);
      setStep(3);
    }, 2000);
  };

  const resetPrediction = () => {
    setStep(1);
    setOdds({ home: '', draw: '', away: '' });
    setPreviousScores(Array(5).fill({ home: '', away: '' }));
    setPredictions(null);
    setError('');
  };

  return (
    <div>
      <h2 className="text-2xl font-bold text-indigo-600 mb-4">FIFA Classique</h2>
      <motion.div
        initial={{ opacity: 0, scale: 0.9 }}
        animate={{ opacity: 1, scale: 1 }}
        transition={{ duration: 0.5 }}
        className="max-w-md mx-auto p-4"
      >
        <div className="flex flex-col items-center mb-6">
          {step === 1 && (
            <div className="welcome-message mt-4">
              <p>
                Bienvenue sur FIFA PREDICT PRO. Notre application utilise des outils de calcul avancés pour fournir des prédictions de match fiables basées sur les cotes et les scores passés.
              </p>
            </div>
          )}
        </div>
        <AnimatePresence>
          {step === 1 && (
            <motion.div
              key="step1"
              initial={{ opacity: 0, x: -50 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 50 }}
              transition={{ duration: 0.3 }}
              className="space-y-4"
            >
              <h2 className="text-xl font-bold text-gray-800">Étape 1: Cotes du Match</h2>
              {['home', 'draw', 'away'].map((type) => (
                <div key={type}>
                  <label htmlFor={type} className="block text-sm font-medium text-gray-700">
                    Cote {type === 'home' ? 'Domicile' : type === 'draw' ? 'Match nul' : 'Extérieur'}
                  </label>
                  <input
                    type="number"
                    id={type}
                    name={type}
                    value={odds[type]}
                    onChange={handleOddsChange}
                    className="custom-input mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                    placeholder="Entrez la cote"
                    step="0.01"
                    min="1.01"
                  />
                </div>
              ))}
              <div className="flex space-x-4">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setCurrentSection('home')}
                  className="custom-button flex-1 py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                >
                  Retour à l'accueil
                </motion.button>
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setStep(2)}
                  className="custom-button flex-1 py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                >
                  Suivant
                </motion.button>
              </div>
            </motion.div>
          )}

          {step === 2 && (
            <motion.div
              key="step2"
              initial={{ opacity: 0, x: -50 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 50 }}
              transition={{ duration: 0.3 }}
              className="space-y-4"
            >
              <h2 className="text-xl font-bold text-gray-800">Étape 2: Scores Précédents</h2>
              <div className="score-list">
                {previousScores.map((score, index) => (
                  <div key={index} className="score-item flex items-center">
                    <span className="score-label mr-2">Match {index + 1}</span>
                    <div className="score-inputs flex space-x-2">
                      <input
                        type="number"
                        value={score.home}
                        onChange={(e) => handlePreviousScoresChange(index, 'home', e.target.value)}
                        className="custom-input score-input mt-1 block border border-gray-300 rounded-md shadow-sm p-1 focus:ring-indigo-500 focus:border-indigo-500"
                        placeholder="Home"
                        min="0"
                      />
                      <input
                        type="number"
                        value={score.away}
                        onChange={(e) => handlePreviousScoresChange(index, 'away', e.target.value)}
                        className="custom-input score-input mt-1 block border border-gray-300 rounded-md shadow-sm p-1 focus:ring-indigo-500 focus:border-indigo-500"
                        placeholder="Away"
                        min="0"
                      />
                    </div>
                  </div>
                ))}
              </div>
              <p className="text-sm text-gray-600 mt-2">
                Important : Veuillez saisir les 5 derniers scores avec précision. Ces données sont cruciales pour la fiabilité de nos prédictions.
              </p>
              <div className="flex space-x-4">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setStep(1)}
                  className="custom-button flex-1 py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                >
                  Retour
                </motion.button>
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={calculatePredictions}
                  className="custom-button flex-1 py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                >
                  Prédire
                </motion.button>
              </div>
            </motion.div>
          )}

          {step === 3 && predictions && (
            <motion.div
              key="step3"
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5 }}
              className="space-y-6"
            >
              <h2 className="text-2xl font-bold text-center text-indigo-600">Résultats de la Prédiction</h2>
              <div className="probability-container">
                {['home', 'draw', 'away'].map((type) => (
                  <div key={type} className="probability-item">
                    <h3 className="text-sm font-medium mb-1">
                      {type === 'home' ? 'Domicile' : type === 'draw' ? 'Match nul' : 'Extérieur'}
                    </h3>
                    <p className="font-bold text-lg">
                      {predictions.probabilities[type]}%
                    </p>
                  </div>
                ))}
              </div>
              <div className="prediction-container">
                {['Mi-temps', 'Temps réglementaire'].map((period, index) => (
                  <div key={period} className="prediction-item">
                    <h3 className="prediction-title">{period}</h3>
                    <div className="grid grid-cols-2 gap-4">
                      {predictions.scores[index === 0 ? 'halfTime' : 'fullTime'].map((score, i) => (
                        <div key={i} className="bg-gray-700 p-3 rounded-lg">
                          <p className="prediction-score">{score}</p>
                        </div>
                      ))}
                    </div>
                  </div>
                ))}
                <div className="prediction-item">
                  <h3 className="prediction-title">Prédiction la plus sûre</h3>
                  <div className="bg-gray-700 p-3 rounded-lg">
                    <p className="prediction-score">
                      {predictions.mostLikelyOutcome}
                    </p>
                    <p className="text-sm text-gray-300 mt-2">
                      {predictions.goalsPrediction.value} buts (Fiabilité: {predictions.goalsPrediction.reliability}%)
                    </p>
                  </div>
                </div>
              </div>
              <div className="flex space-x-4">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={resetPrediction}
                  className="custom-button flex-1 py-3 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                >
                  Nouvelle prédiction
                </motion.button>
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setCurrentSection('home')}
                  className="custom-button flex-1 py-3 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                >
                  Page d'accueil
                </motion.button>
              </div>
            </motion.div>
          )}
        </AnimatePresence>

        {loading && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 loading-overlay">
            <div className="bg-white text-gray-800 p-6 rounded-lg shadow-xl">
              <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-indigo-500 mx-auto loading-spinner"></div>
              <p className="mt-4 text-center">Chargement en cours...</p>
            </div>
          </div>
        )}

        {error && (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            className="mt-4 bg-red-50 border-l-4 border-red-400 p-4 rounded-r-lg"
          >
            <p className="text-sm text-red-700">{error}</p>
          </motion.div>
        )}
      </motion.div>
    </div>
  );
};

const SegaFootball = ({ setCurrentSection }) => {
  const [step, setStep] = useState(1);
  const [odds, setOdds] = useState({ home: '', draw: '', away: '' });
  const [previousScores, setPreviousScores] = useState(Array(5).fill({ home: '', away: '' }));
  const [predictions, setPredictions] = useState(null);
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleOddsChange = (e) => {
    setOdds({ ...odds, [e.target.name]: e.target.value });
  };

  const handlePreviousScoresChange = (index, team, value) => {
    const newScores = [...previousScores];
    newScores[index] = { ...newScores[index], [team]: value };
    setPreviousScores(newScores);
  };

  const calculatePredictions = () => {
    setError('');
    setLoading(true);

    if (!odds.home || !odds.draw || !odds.away) {
      setError('Veuillez entrer toutes les cotes.');
      setLoading(false);
      return;
    }

    const homeOdds = parseFloat(odds.home);
    const drawOdds = parseFloat(odds.draw);
    const awayOdds = parseFloat(odds.away);

    if (homeOdds <= 1 || drawOdds <= 1 || awayOdds <= 1) {
      setError('Les cotes doivent être supérieures à 1.');
      setLoading(false);
      return;
    }

    const validScores = previousScores.filter(score => score.home !== '' && score.away !== '');
    if (validScores.length === 0) {
      setError('Veuillez entrer au moins un score valide.');
      setLoading(false);
      return;
    }

    setTimeout(() => {
      const totalProb = (1 / homeOdds) + (1 / drawOdds) + (1 / awayOdds);
      const homeProb = (1 / homeOdds) / totalProb * 100;
      const drawProb = (1 / drawOdds) / totalProb * 100;
      const awayProb = (1 / awayOdds) / totalProb * 100;

      const avgHomeScore = validScores.reduce((sum, score) => sum + parseInt(score.home), 0) / validScores.length;
      const avgAwayScore = validScores.reduce((sum, score) => sum + parseInt(score.away), 0) / validScores.length;

      const predictScore = (avgScore, prob, factor = 1) => {
        const baseScore = avgScore * (prob / 50) + Math.random() * 0.5;
        return Math.max(0, Math.round(baseScore * factor * (1 + (Math.random() - 0.5) * 0.2)));
      };

      let homeScore1, awayScore1, homeScore2, awayScore2;
      do {
        homeScore1 = predictScore(avgHomeScore, homeProb, 1.3);
        awayScore1 = predictScore(avgAwayScore, awayProb, 1.3);
        homeScore2 = predictScore(avgHomeScore, homeProb, 1.4);
        awayScore2 = predictScore(avgAwayScore, awayProb, 1.4);
      } while (homeScore1 === homeScore2 && awayScore1 === awayScore2);

      const totalGoals1 = homeScore1 + awayScore1;
      const totalGoals2 = homeScore2 + awayScore2;
      const avgTotalGoals = (totalGoals1 + totalGoals2) / 2;

      let mostLikelyGoals;
      let reliability;

      if (avgTotalGoals <= 2.5) {
        mostLikelyGoals = "2.5";
        reliability = Math.floor(85 + (avgTotalGoals / 2.5) * 10);
      } else if (avgTotalGoals <= 3.5) {
        mostLikelyGoals = "3.5";
        reliability = Math.floor(80 + ((avgTotalGoals - 2.5) / 1) * 15);
      } else {
        mostLikelyGoals = "4.5";
        reliability = Math.floor(75 + ((avgTotalGoals - 3.5) / 1.5) * 20);
      }

      reliability = Math.min(95, Math.max(70, reliability));

      let mostLikelyOutcome;
      if (homeProb > awayProb && homeProb > drawProb) {
        mostLikelyOutcome = homeProb - drawProb > 20 ? "1" : "1X";
      } else if (awayProb > homeProb && awayProb > drawProb) {
        mostLikelyOutcome = awayProb - drawProb > 20 ? "2" : "2X";
      } else {
        mostLikelyOutcome = "12";
      }

      setPredictions({
        probabilities: {
          home: homeProb.toFixed(2),
          draw: drawProb.toFixed(2),
          away: awayProb.toFixed(2)
        },
        scores: {
          fullTime: [`${homeScore1} - ${awayScore1}`, `${homeScore2} - ${awayScore2}`],
          halfTime: [
            `${Math.max(0, Math.floor(homeScore1 / 2))} - ${Math.max(0, Math.floor(awayScore1 / 2))}`,
            `${Math.max(0, Math.floor(homeScore2 / 2))} - ${Math.max(0, Math.floor(awayScore2 / 2))}`
          ]
        },
        goalsPrediction: {
          value: mostLikelyGoals,
          reliability: reliability
        },
        mostLikelyOutcome: mostLikelyOutcome
      });

      setLoading(false);
      setStep(3);
    }, 2000);
  };

  const resetPrediction = () => {
    setStep(1);
    setOdds({ home: '', draw: '', away: '' });
    setPreviousScores(Array(5).fill({ home: '', away: '' }));
    setPredictions(null);
    setError('');
  };

  return (
    <div>
      <h2 className="text-2xl font-bold text-green-600 mb-4">SEGA FOOTBALL</h2>
      <motion.div
        initial={{ opacity: 0, scale: 0.9 }}
        animate={{ opacity: 1, scale: 1 }}
        transition={{ duration: 0.5 }}
        className="max-w-md mx-auto p-4"
      >
        <div className="flex flex-col items-center mb-6">
          {step === 1 && (
            <div className="welcome-message mt-4">
              <p>
                Bienvenue sur SEGA FOOTBALL. Utilisez les outils de calcul avancés pour des prédictions de match fiables basées sur les cotes et les 5 derniers scores de confrontation.
              </p>
            </div>
          )}
        </div>
        <AnimatePresence>
          {step === 1 && (
            <motion.div
              key="step1"
              initial={{ opacity: 0, x: -50 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 50 }}
              transition={{ duration: 0.3 }}
              className="space-y-4"
            >
              <h2 className="text-xl font-bold text-gray-800">Étape 1: Cotes du Match</h2>
              {['home', 'draw', 'away'].map((type) => (
                <div key={type}>
                  <label htmlFor={type} className="block text-sm font-medium text-gray-700">
                    Cote {type === 'home' ? 'Domicile' : type === 'draw' ? 'Match nul' : 'Extérieur'}
                  </label>
                  <input
                    type="number"
                    id={type}
                    name={type}
                    value={odds[type]}
                    onChange={handleOddsChange}
                    className="custom-input mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-green-500 focus:border-green-500"
                    placeholder="Entrez la cote"
                    step="0.01"
                    min="1.01"
                  />
                </div>
              ))}
              <div className="flex space-x-4">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setCurrentSection('home')}
                  className="custom-button flex-1 py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
                >
                  Retour à l'accueil
                </motion.button>
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setStep(2)}
                  className="custom-button flex-1 py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
                >
                  Suivant
                </motion.button>
              </div>
            </motion.div>
          )}

          {step === 2 && (
            <motion.div
              key="step2"
              initial={{ opacity: 0, x: -50 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 50 }}
              transition={{ duration: 0.3 }}
              className="space-y-4"
            >
              <h2 className="text-xl font-bold text-gray-800">Étape 2: Scores Précédents</h2>
              <div className="score-list">
                {previousScores.map((score, index) => (
                  <div key={index} className="score-item flex items-center">
                    <span className="score-label mr-2">Match {index + 1}</span>
                    <div className="score-inputs flex space-x-2">
                      <input
                        type="number"
                        value={score.home}
                        onChange={(e) => handlePreviousScoresChange(index, 'home', e.target.value)}
                        className="custom-input score-input mt-1 block border border-gray-300 rounded-md shadow-sm p-1 focus:ring-green-500 focus:border-green-500"
                        placeholder="Home"
                        min="0"
                      />
                      <input
                        type="number"
                        value={score.away}
                        onChange={(e) => handlePreviousScoresChange(index, 'away', e.target.value)}
                        className="custom-input score-input mt-1 block border border-gray-300 rounded-md shadow-sm p-1 focus:ring-green-500 focus:border-green-500"
                        placeholder="Away"
                        min="0"
                      />
                    </div>
                  </div>
                ))}
              </div>
              <p className="text-sm text-gray-600 mt-2">
                Important : Veuillez saisir les 5 derniers scores avec précision. Ces données sont cruciales pour la fiabilité de nos prédictions.
              </p>
              <div className="flex space-x-4">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setStep(1)}
                  className="custom-button flex-1 py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
                >
                  Retour
                </motion.button>
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={calculatePredictions}
                  className="custom-button flex-1 py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
                >
                  Prédire
                </motion.button>
              </div>
            </motion.div>
          )}

          {step === 3 && predictions && (
            <motion.div
              key="step3"
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5 }}
              className="space-y-6"
            >
              <h2 className="text-2xl font-bold text-center text-green-600">Résultats de la Prédiction</h2>
              <div className="probability-container">
                {['home', 'draw', 'away'].map((type) => (
                  <div key={type} className="probability-item">
                    <h3 className="text-sm font-medium mb-1">
                      {type === 'home' ? 'Domicile' : type === 'draw' ? 'Match nul' : 'Extérieur'}
                    </h3>
                    <p className="font-bold text-lg">
                      {predictions.probabilities[type]}%
                    </p>
                  </div>
                ))}
              </div>
              <div className="prediction-container">
                {['Mi-temps', 'Temps réglementaire'].map((period, index) => (
                  <div key={period} className="prediction-item">
                    <h3 className="prediction-title">{period}</h3>
                    <div className="grid grid-cols-2 gap-4">
                      {predictions.scores[index === 0 ? 'halfTime' : 'fullTime'].map((score, i) => (
                        <div key={i} className="bg-gray-700 p-3 rounded-lg">
                          <p className="prediction-score">{score}</p>
                        </div>
                      ))}
                    </div>
                  </div>
                ))}
                <div className="prediction-item">
                  <h3 className="prediction-title">Prédiction la plus sûre</h3>
                  <div className="bg-gray-700 p-3 rounded-lg">
                    <p className="prediction-score">
                      {predictions.mostLikelyOutcome}
                    </p>
                    <p className="text-sm text-gray-300 mt-2">
                      {predictions.goalsPrediction.value} buts (Fiabilité: {predictions.goalsPrediction.reliability}%)
                    </p>
                  </div>
                </div>
              </div>
              <div className="flex space-x-4">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={resetPrediction}
                  className="custom-button flex-1 py-3 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
                >
                  Nouvelle prédiction
                </motion.button>
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setCurrentSection('home')}
                  className="custom-button flex-1 py-3 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
                >
                  Page d'accueil
                </motion.button>
              </div>
            </motion.div>
          )}
        </AnimatePresence>

        {loading && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 loading-overlay">
            <div className="bg-white text-gray-800 p-6 rounded-lg shadow-xl">
              <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-green-500 mx-auto loading-spinner"></div>
              <p className="mt-4 text-center">Chargement en cours...</p>
            </div>
          </div>
        )}

        {error && (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            className="mt-4 bg-red-50 border-l-4 border-red-400 p-4 rounded-r-lg"
          >
            <p className="text-sm text-red-700">{error}</p>
          </motion.div>
        )}
      </motion.div>
    </div>
  );
};

const FifaHot = ({ setCurrentSection }) => {
  const [step, setStep] = useState(1);
  const [odds, setOdds] = useState({ home: '', draw: '', away: '' });
  const [previousScores, setPreviousScores] = useState(Array(5).fill({ home: '', away: '' }));
  const [predictions, setPredictions] = useState(null);
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleOddsChange = (e) => {
    setOdds({ ...odds, [e.target.name]: e.target.value });
  };

  const handlePreviousScoresChange = (index, team, value) => {
    const newScores = [...previousScores];
    newScores[index] = { ...newScores[index], [team]: value };
    setPreviousScores(newScores);
  };

  const calculatePredictions = () => {
    setError('');
    setLoading(true);

    if (!odds.home || !odds.draw || !odds.away) {
      setError('Veuillez entrer toutes les cotes.');
      setLoading(false);
      return;
    }

    const homeOdds = parseFloat(odds.home);
    const drawOdds = parseFloat(odds.draw);
    const awayOdds = parseFloat(odds.away);

    if (homeOdds <= 1 || drawOdds <= 1 || awayOdds <= 1) {
      setError('Les cotes doivent être supérieures à 1.');
      setLoading(false);
      return;
    }

    const validScores = previousScores.filter(score => score.home !== '' && score.away !== '');
    if (validScores.length === 0) {
      setError('Veuillez entrer au moins un score valide.');
      setLoading(false);
      return;
    }

    setTimeout(() => {
      const totalProb = (1 / homeOdds) + (1 / drawOdds) + (1 / awayOdds);
      const homeProb = (1 / homeOdds) / totalProb * 100;
      const drawProb = (1 / drawOdds) / totalProb * 100;
      const awayProb = (1 / awayOdds) / totalProb * 100;

      const avgHomeScore = validScores.reduce((sum, score) => sum + parseInt(score.home), 0) / validScores.length;
      const avgAwayScore = validScores.reduce((sum, score) => sum + parseInt(score.away), 0) / validScores.length;

      const predictScore = (avgScore, prob, factor = 1) => {
        const baseScore = avgScore * (prob / 50) * factor;
        return Math.max(0, Math.round(baseScore));
      };

      let homeScore1, awayScore1, homeScore2, awayScore2;
      do {
        homeScore1 = predictScore(avgHomeScore, homeProb, 1.8);
        awayScore1 = predictScore(avgAwayScore, awayProb, 1.8);
        homeScore2 = predictScore(avgHomeScore, homeProb, 2.0);
        awayScore2 = predictScore(avgAwayScore, awayProb, 2.0);
      } while (homeScore1 === homeScore2 && awayScore1 === awayScore2);

      const totalGoals1 = homeScore1 + awayScore1;
      const totalGoals2 = homeScore2 + awayScore2;
      const avgTotalGoals = (totalGoals1 + totalGoals2) / 2;

      let mostLikelyGoals;
      let reliability;

      if (avgTotalGoals <= 4) {
        mostLikelyGoals = "4.5";
        reliability = 85;
      } else if (avgTotalGoals <= 6) {
        mostLikelyGoals = "5.5";
        reliability = 90;
      } else {
        mostLikelyGoals = "6.5";
        reliability = 95;
      }

      let mostLikelyOutcome;
      if (homeProb > awayProb && homeProb > drawProb) {
        mostLikelyOutcome = homeProb - drawProb > 20 ? "1" : "1X";
      } else if (awayProb > homeProb && awayProb > drawProb) {
        mostLikelyOutcome = awayProb - drawProb > 20 ? "2" : "2X";
      } else {
        mostLikelyOutcome = "12";
      }

      setPredictions({
        probabilities: {
          home: homeProb.toFixed(2),
          draw: drawProb.toFixed(2),
          away: awayProb.toFixed(2)
        },
        scores: {
          fullTime: [`${homeScore1} - ${awayScore1}`, `${homeScore2} - ${awayScore2}`],
          halfTime: [
            `${Math.max(0, Math.floor(homeScore1 / 2))} - ${Math.max(0, Math.floor(awayScore1 / 2))}`,
            `${Math.max(0, Math.floor(homeScore2 / 2))} - ${Math.max(0, Math.floor(awayScore2 / 2))}`
          ]
        },
        goalsPrediction: {
          value: mostLikelyGoals,
          reliability: reliability
        },
        mostLikelyOutcome: mostLikelyOutcome
      });

      setLoading(false);
      setStep(3);
    }, 2000);
  };

  const resetPrediction = () => {
    setStep(1);
    setOdds({ home: '', draw: '', away: '' });
    setPreviousScores(Array(5).fill({ home: '', away: '' }));
    setPredictions(null);
    setError('');
  };

  return (
    <div>
      <h2 className="text-2xl font-bold text-red-600 mb-4">FIFA HOT</h2>
      <motion.div
        initial={{ opacity: 0, scale: 0.9 }}
        animate={{ opacity: 1, scale: 1 }}
        transition={{ duration: 0.5 }}
        className="max-w-md mx-auto p-4"
      >
        <div className="flex flex-col items-center mb-6">
          {step === 1 && (
            <div className="welcome-message mt-4">
              <p>
                Bienvenue sur FIFA HOT. Utilisez les outils de calcul avancés pour des prédictions de match à haut score basées sur les cotes et les 5 derniers scores de confrontation.
              </p>
            </div>
          )}
        </div>
        <AnimatePresence>
          {step === 1 && (
            <motion.div
              key="step1"
              initial={{ opacity: 0, x: -50 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 50 }}
              transition={{ duration: 0.3 }}
              className="space-y-4"
            >
              <h2 className="text-xl font-bold text-gray-800">Étape 1: Cotes du Match</h2>
              {['home', 'draw', 'away'].map((type) => (
                <div key={type}>
                  <label htmlFor={type} className="block text-sm font-medium text-gray-700">
                    Cote {type === 'home' ? 'Domicile' : type === 'draw' ? 'Match nul' : 'Extérieur'}
                  </label>
                  <input
                    type="number"
                    id={type}
                    name={type}
                    value={odds[type]}
                    onChange={handleOddsChange}
                    className="custom-input mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-red-500 focus:border-red-500"
                    placeholder="Entrez la cote"
                    step="0.01"
                    min="1.01"
                  />
                </div>
              ))}
              <div className="flex space-x-4">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setCurrentSection('home')}
                  className="custom-button flex-1 py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
                >
                  Retour à l'accueil
                </motion.button>
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setStep(2)}
                  className="custom-button flex-1 py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
                >
                  Suivant
                </motion.button>
              </div>
            </motion.div>
          )}

          {step === 2 && (
            <motion.div
              key="step2"
              initial={{ opacity: 0, x: -50 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 50 }}
              transition={{ duration: 0.3 }}
              className="space-y-4"
            >
              <h2 className="text-xl font-bold text-gray-800">Étape 2: Scores Précédents</h2>
              <div className="score-list">
                {previousScores.map((score, index) => (
                  <div key={index} className="score-item flex items-center">
                    <span className="score-label mr-2">Match {index + 1}</span>
                    <div className="score-inputs flex space-x-2">
                      <input
                        type="number"
                        value={score.home}
                        onChange={(e) => handlePreviousScoresChange(index, 'home', e.target.value)}
                        className="custom-input score-input mt-1 block border border-gray-300 rounded-md shadow-sm p-1 focus:ring-red-500 focus:border-red-500"
                        placeholder="Home"
                        min="0"
                      />
                      <input
                        type="number"
                        value={score.away}
                        onChange={(e) => handlePreviousScoresChange(index, 'away', e.target.value)}
                        className="custom-input score-input mt-1 block border border-gray-300 rounded-md shadow-sm p-1 focus:ring-red-500 focus:border-red-500"
                        placeholder="Away"
                        min="0"
                      />
                    </div>
                  </div>
                ))}
              </div>
              <p className="text-sm text-gray-600 mt-2">
                Important : Veuillez saisir les 5 derniers scores avec précision. Pour chaque match, entrez les scores de la première période ayant le total le plus bas. Ces données sont cruciales pour la fiabilité de nos prédictions.
              </p>
              <div className="flex space-x-4">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setStep(1)}
                  className="custom-button flex-1 py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
                >
                  Retour
                </motion.button>
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={calculatePredictions}
                  className="custom-button flex-1 py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
                >
                  Prédire
                </motion.button>
              </div>
            </motion.div>
          )}

          {step === 3 && predictions && (
            <motion.div
              key="step3"
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5 }}
              className="space-y-6"
            >
              <h2 className="text-2xl font-bold text-center text-red-600">Résultats de la Prédiction</h2>
              <div className="probability-container">
                {['home', 'draw', 'away'].map((type) => (
                  <div key={type} className="probability-item">
                    <h3 className="text-sm font-medium mb-1">
                      {type === 'home' ? 'Domicile' : type === 'draw' ? 'Match nul' : 'Extérieur'}
                    </h3>
                    <p className="font-bold text-lg">
                      {predictions.probabilities[type]}%
                    </p>
                  </div>
                ))}
              </div>
              <div className="prediction-container">
                {['Mi-temps', 'Temps réglementaire'].map((period, index) => (
                  <div key={period} className="prediction-item">
                    <h3 className="prediction-title">{period}</h3>
                    <div className="grid grid-cols-2 gap-4">
                      {predictions.scores[index === 0 ? 'halfTime' : 'fullTime'].map((score, i) => (
                        <div key={i} className="bg-gray-700 p-3 rounded-lg">
                          <p className="prediction-score">{score}</p>
                        </div>
                      ))}
                    </div>
                  </div>
                ))}
                <div className="prediction-item">
                  <h3 className="prediction-title">Prédiction la plus sûre</h3>
                  <div className="bg-gray-700 p-3 rounded-lg">
                    <p className="prediction-score">
                      {predictions.mostLikelyOutcome}
                    </p>
                    <p className="text-sm text-gray-300 mt-2">
                      {predictions.goalsPrediction.value} buts (Fiabilité: {predictions.goalsPrediction.reliability}%)
                    </p>
                  </div>
                </div>
              </div>
              <div className="flex space-x-4">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={resetPrediction}
                  className="custom-button flex-1 py-3 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
                >
                  Nouvelle prédiction
                </motion.button>
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setCurrentSection('home')}
                  className="custom-button flex-1 py-3 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
                >
                  Page d'accueil
                </motion.button>
              </div>
            </motion.div>
          )}
        </AnimatePresence>

        {loading && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 loading-overlay">
            <div className="bg-white text-gray-800 p-6 rounded-lg shadow-xl">
              <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-red-500 mx-auto loading-spinner"></div>
              <p className="mt-4 text-center">Chargement en cours...</p>
            </div>
          </div>
        )}

        {error && (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            className="mt-4 bg-red-50 border-l-4 border-red-400 p-4 rounded-r-lg"
          >
            <p className="text-sm text-red-700">{error}</p>
          </motion.div>
        )}
      </motion.div>
    </div>
  );
};

ReactDOM.render(<FifaPredictPro />, document.getElementById('root'));
</script>
</div>
</body>
</html>
